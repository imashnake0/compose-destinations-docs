"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[8680],{2042:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var t=a(4848),i=a(8453);const s={sidebar_position:4},o="Navigation Arguments",r={id:"arguments/navigation-arguments",title:"Navigation Arguments",description:"Types",source:"@site/docs/arguments/navigation-arguments.md",sourceDirName:"arguments",slug:"/arguments/navigation-arguments",permalink:"/v2/arguments/navigation-arguments",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/docs/arguments/navigation-arguments.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Defining Destinations",permalink:"/v2/defining-destinations"},next:{title:"Arguments from NavHost",permalink:"/v2/arguments/nav-host-parameters"}},l={},d=[{value:"Types",id:"types",level:2},{value:"Custom navigation argument types",id:"custom-navigation-argument-types",level:3},{value:"Destination Navigation arguments",id:"destination-navigation-arguments",level:2},{value:"NavGraph Navigation arguments",id:"navgraph-navigation-arguments",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"navigation-arguments",children:"Navigation Arguments"}),"\n",(0,t.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,t.jsx)(n.p,{children:"Compose destinations will consider the following types as navigation argument types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"String"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Boolean"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Int"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Long"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Float"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Parcelable"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Serializable"})," (java.io)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Enums"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/Kotlin/kotlinx.serialization",children:"@kotlinx.serialization.Serializable"})," annotated types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#custom-navigation-argument-types",children:"Custom navigation types"})," (Types for which the user has defined a serialization to and from string)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Array"})," and ",(0,t.jsx)(n.code,{children:"ArrayList"})," of the above types"]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["For ",(0,t.jsx)(n.code,{children:"Boolean"}),", ",(0,t.jsx)(n.code,{children:"Int"}),", ",(0,t.jsx)(n.code,{children:"Float"}),", ",(0,t.jsx)(n.code,{children:"Long"}),", you'll need to use ",(0,t.jsx)(n.code,{children:"BooleanArray"}),", ",(0,t.jsx)(n.code,{children:"IntArray"}),", ",(0,t.jsx)(n.code,{children:"FloatArray"}),", ",(0,t.jsx)(n.code,{children:"LongArray"})," instead of ",(0,t.jsx)(n.code,{children:"Array<Boolean>"}),", ",(0,t.jsx)(n.code,{children:"Array<Int>"}),", ",(0,t.jsx)(n.code,{children:"Array<Float>"}),", ",(0,t.jsx)(n.code,{children:"Array<Long>"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.code,{children:"navArgs"})," of either ",(0,t.jsx)(n.code,{children:"@Destination"})," or ",(0,t.jsx)(n.code,{children:"@NavGraph"}),", the data class passed in holds\nall navigation arguments, it is ",(0,t.jsx)(n.strong,{children:"NOT"})," itself the navigation argument.\nSo that class doesn't need to be ",(0,t.jsx)(n.code,{children:"Serializable"})," or ",(0,t.jsx)(n.code,{children:"Parcelable"}),". Instead, its fields need to."]})}),"\n",(0,t.jsx)(n.h3,{id:"custom-navigation-argument-types",children:"Custom navigation argument types"}),"\n",(0,t.jsx)(n.p,{children:"Besides types that are navigation arguments out of the box, you can make any type be considered a navigation argument type with a one-time easy setup."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["This feature can also be used to define how ",(0,t.jsx)(n.code,{children:"Parcelable"})," or ",(0,t.jsx)(n.code,{children:"Serializable"})," types will be represented in the route. This is useful if you want to deep link into a Screen that has one of these navigation arguments. Read more ",(0,t.jsx)(n.a,{href:"../deeplinks#screens-with-mandatory-complex-navigation-arguments-types",children:"here"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["You may know that internally, Official Compose Navigation uses string routes to navigate. Well, to make an argument be able to be passed from screen to screen, we need to be able to convert its type to string and back. Hence, there is a ",(0,t.jsx)(n.code,{children:"DestinationsNavTypeSerializer"})," interface that you can implement and annotate with ",(0,t.jsx)(n.code,{children:"@NavTypeSerializer"})," to make code generation consider that type argument a type that can be passed when navigating."]}),"\n",(0,t.jsx)(n.p,{children:"Here is an example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"import androidx.compose.ui.graphics.Color\n//...\n\n@NavTypeSerializer\nclass ColorTypeSerializer : DestinationsNavTypeSerializer<Color> {\n    override fun toRouteString(value: Color): String =\n        value.toArgb().toString()\n\n    override fun fromRouteString(routeStr: String): Color =\n        Color(routeStr.toInt())\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["After this, you can pass ",(0,t.jsx)(n.code,{children:"androidx.compose.ui.graphics.Color"})," as you would any other navigation argument."]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["While this feature can be super helpful, remember that you should not be sending big classes in navigation.\nThe above example is perfect because ",(0,t.jsx)(n.code,{children:"Color"})," is simple structure.",(0,t.jsx)(n.br,{}),"\n","Anyway, Compose Destinations gives you the tools to easily do this so you can test it with less upfront work. This is possible to do with Official Compose Navigation, but the setup is way more involved."]})}),"\n",(0,t.jsx)(n.h2,{id:"destination-navigation-arguments",children:"Destination Navigation arguments"}),"\n",(0,t.jsxs)(n.p,{children:["For Composables annotated with ",(0,t.jsx)(n.code,{children:"@Destination"}),", there are two ways of defining nav arguments:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"You can simply pass arguments of navigation argument types\nand Compose Destinations will pick them up and register them accordingly."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@Destination<RootGraph>\n@Composable\nfun ProfileScreen(\n    id: Int // <- this will be a mandatory navigation argument!\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"If some of the arguments are not mandatory, i.e they may not be sent when navigating to this screen, you can mark them as nullable or define default values for them."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@Destination<RootGraph>\n@Composable\nfun ProfileScreen(\n    id: Int = -1, // <- optional navigation argument. If it is not sent by previous screen, -1 will be received here\n    name: String? = null // <- optional navigation argument. It will be null if not sent by previous screen\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Navigation arguments' default values must be resolvable from the generated ",(0,t.jsx)(n.code,{children:"Destination"})," class, so you cannot use private values as default for navigation arguments."]}),"\n",(0,t.jsx)(n.p,{children:"This approach is simple and works great if you intend to use the navigation arguments inside the screen Composable. However, if you do not, for example, if you use a ViewModel for that screen and it is the one that will actually use the navigation arguments, it would be awkward to have to declare them in the Composable function."}),"\n",(0,t.jsx)(n.p,{children:"So in these cases,"}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"You can define a class to hold all nav args"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"All the information above, regarding defining navigation arguments in the Composable itself, is also valid when defining the arguments this way. The difference is just that now we will get the arguments info from the constructor parameters and before we would get them from the Composable function parameters."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"data class ProfileScreenNavArgs(\n    val id: Int = -1,\n    val groupName: String? = null\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then in the ",(0,t.jsx)(n.code,{children:"@Destination"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@Destination<RootGraph>(\n    navArgs = ProfileScreenNavArgs::class\n)\nfun ProfileScreen() { /*...*/ }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that we can also still receive the arguments in the Composable too if we declare a parameter of the ",(0,t.jsx)(n.code,{children:"navArgsDelegate"})," class, but you cannot define any other argument of navigation type (you should not need to anyway). A compile-time check is in place to make sure this is respected."]}),"\n",(0,t.jsxs)(n.p,{children:["When using this feature, you'll notice that the generated Destination's ",(0,t.jsx)(n.code,{children:"argsFrom"})," methods will return the delegate navigation arguments class:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"override fun argsFrom(navBackStackEntry: NavBackStackEntry): ProfileScreenNavArgs {\n    //...\n}\n\noverride fun argsFrom(savedStateHandle: SavedStateHandle): ProfileScreenNavArgs {\n    //...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can use the second one to get the arguments in the ViewModel from the ",(0,t.jsx)(n.code,{children:"SavedStateHandle"}),".\nOr you can use generated extension function ",(0,t.jsx)(n.code,{children:"navArgs"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val navArgs: ProfileScreenNavArgs = ProfileScreenDestination.argsFrom(savedStateHandle)\n\n// OR\n\nval navArgs: ProfileScreenNavArgs = savedStateHandle.navArgs()\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Do not try to access a specific navigation argument by its string key from the ",(0,t.jsx)(n.code,{children:"SavedStateHandle"})," or the ",(0,t.jsx)(n.code,{children:"NavBackStackEntry"}),". Compose Destinations is here to abstract you from this and so internally it may be using\ndifferent types than what you expect.",(0,t.jsx)(n.br,{}),"\n","If you really need to do it for some reason, use the corresponding NavType class ",(0,t.jsx)(n.code,{children:"get"})," methods. You can check in the generated ",(0,t.jsx)(n.code,{children:"Destination"})," how it does it in the ",(0,t.jsx)(n.code,{children:"argsFrom"})," methods."]})}),"\n",(0,t.jsx)(n.h2,{id:"navgraph-navigation-arguments",children:"NavGraph Navigation arguments"}),"\n",(0,t.jsxs)(n.p,{children:["To define arguments on nav graphs, you can use ",(0,t.jsx)(n.code,{children:"navArgs"})," parameter of ",(0,t.jsx)(n.code,{children:"@NavGraph"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"data class ProfileGraphArgs(\n    val id: String\n)\n\n@NavGraph<RootGraph>(\n    navArgs = ProfileGraphArgs::class\n)\nannotation class ProfileGraph\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To retrieve the arguments, it's similar to how we do for destinations. They also work for both ",(0,t.jsx)(n.code,{children:"SavedStateHandle"})," or ",(0,t.jsx)(n.code,{children:"NavBackStackEntry"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Either:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val profileArgs: ProfileGraphArgs? = ProfileNavGraph.argsFrom(savedStateHandle)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val profileArgs: ProfileGraphArgs? = savedStateHandle.navGraphArgs<ProfileGraphArgs>()\n"})}),"\n",(0,t.jsx)(n.p,{children:"If both the nav graph and its start route have arguments, a new class that contains both those arguments classes will be generated. So the types shown in the example above would likely be different."}),"\n",(0,t.jsxs)(n.admonition,{title:"Nav graph arguments are always nullable",type:"caution",children:[(0,t.jsxs)(n.p,{children:["Navigation arguments of nav graphs are tricky. They will be present if you navigate to the graph itself\n(for above example, doing ",(0,t.jsx)(n.code,{children:'navigator.navigate(ProfileNavGraph(id = "some id"))'}),") and they will not be present\nif you navigate to one of its destinations directly.",(0,t.jsx)(n.br,{}),"\n","This is how official compose navigation works as well, Compose Destinations makes it clear by returning nullable.",(0,t.jsx)(n.br,{}),"\n","If you know in your case you always navigate to the Graph, you can do ",(0,t.jsx)(n.code,{children:"requireNavGraphArgs"})," instead which will throw\nan exception instead of returning nullable type."]}),(0,t.jsxs)(n.p,{children:["Read more about navigating to nav graphs ",(0,t.jsx)(n.a,{href:"../navigation/basics#navigate-to-navgraphs",children:"here"}),"."]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var t=a(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);