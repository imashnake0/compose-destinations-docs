"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[203],{3905:(e,n,t)=>{t.d(n,{Zo:()=>h,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},h=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=p(t),g=i,m=d["".concat(l,".").concat(g)]||d[g]||u[g]||o;return t?a.createElement(m,r(r({ref:n},h),{},{components:t})):a.createElement(m,r({ref:n},h))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},5710:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=t(3117),i=(t(7294),t(3905));const o={sidebar_position:7},r="Defining your Navigation Graphs",s={unversionedId:"defining-navgraphs",id:"version-1.x/defining-navgraphs",title:"Defining your Navigation Graphs",description:"In Compose Destinations, we have an interface that defines a navigation graph in its most simple form.",source:"@site/versioned_docs/version-1.x/defining-navgraphs.md",sourceDirName:".",slug:"/defining-navgraphs",permalink:"/defining-navgraphs",draft:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/versioned_docs/version-1.x/defining-navgraphs.md",tags:[],version:"1.x",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Navigation Host Composables",permalink:"/navhosts"},next:{title:"Styles and Animations",permalink:"/styles-and-animations"}},l={},p=[{value:"Generating navigation graphs",id:"generating-navigation-graphs",level:2},{value:"Through @NavGraph annotations",id:"through-navgraph-annotations",level:3},{value:"(DEPRECATED) Through @Destination annotation",id:"deprecated-through-destination-annotation",level:3},{value:"Manually defining navigation graphs",id:"manually-defining-navigation-graphs",level:2},{value:"&quot;Vanilla NavHosts&quot;",id:"vanilla-navhosts",level:2}],h={toc:p},d="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"defining-your-navigation-graphs"},"Defining your Navigation Graphs"),(0,i.kt)("p",null,"In Compose Destinations, we have an interface that defines a navigation graph in its most simple form.\nHere is what it looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface NavGraphSpec: Direction, Route {\n\n    override val route: String\n\n    val startRoute: Route\n\n    val destinationsByRoute: Map<String, DestinationSpec<*>>\n\n    val nestedNavGraphs: List<NavGraphSpec> get() = emptyList()\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'When running in "single-module" mode, KSP will also generate a ',(0,i.kt)("inlineCode",{parentName:"p"},"NavGraph")," data class\nthat implements the above interface but exposes the generated sealed version of ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationSpec"),"\ninstead.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"By default"),", all your destinations will belong to a ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraph"),' we call "root". This ',(0,i.kt)("inlineCode",{parentName:"p"},"NavGraph")," instance will be generated in an object called ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraphs"),". So, you can access it via ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraphs.root")," and you should pass it into ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationsNavHost")," call.\nIn some situations, however, you might want to:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Group some of your destinations in nested navigation graphs."),(0,i.kt)("li",{parentName:"ol"},'Have multiple top-level (or "root") navigation graphs, so you can use each one in different ',(0,i.kt)("inlineCode",{parentName:"li"},"DestinationsNavHost")," Composables.")),(0,i.kt)("h2",{id:"generating-navigation-graphs"},"Generating navigation graphs"),(0,i.kt)("h3",{id:"through-navgraph-annotations"},"Through @NavGraph annotations"),(0,i.kt)("p",null,"To define a navigation graph, you need to create an annotation class annotated with ",(0,i.kt)("inlineCode",{parentName:"p"},"@NavGraph"),". For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"@NavGraph\nannotation class SettingsNavGraph(\n    val start: Boolean = false\n)\n")),(0,i.kt)("p",null,"Note the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," parameter. It is mandatory and it is enforced at compile time. The ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraph")," annotation has two parameters: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default")," : if true, then all ",(0,i.kt)("inlineCode",{parentName:"li"},"@Destination")," Composable functions that don't specify a navigation graph, will belong to it. There is a ",(0,i.kt)("inlineCode",{parentName:"li"},"@RootNavGraph")," in the core library that by default takes this role if no other sets ",(0,i.kt)("inlineCode",{parentName:"li"},"default = true"),".\nThere can only be one default navigation graph per module. This is enforced at compile time."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"route")," : the route of the navigation graph. By default, the name of the annotation class will be used (without 'NavGraph') suffix and in snake case.")),(0,i.kt)("p",null,"To make destinations part of this navigation graph, you need to annotate them with it!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"@SettingsNavGraph(start = true)\n@Destination\n@Composable\nfun SettingsMainScreen()\n")),(0,i.kt)("p",null,"Remember the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," parameter? You can use it on the destination you wish to use as the start destination of that navigation graph."),(0,i.kt)("p",null,"To make this navigation graph nested in some other navigation graph, annotate it with the parent's annotation!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"@RootNavGraph\n@NavGraph\nannotation class SettingsNavGraph(\n    val start: Boolean = false\n)\n")),(0,i.kt)("p",null,"This makes ",(0,i.kt)("inlineCode",{parentName:"p"},"settings")," a nested navigation graph of ",(0,i.kt)("inlineCode",{parentName:"p"},"root"),". It's that simple. If you don't set any parent of a navigation graph, then it will be a \"top-level\" one, ideal to pass to a ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationsNavHost")," call."),(0,i.kt)("p",null,"You can also make nested navigation graphs the start of a parent navigation graph. Just as you do with destinations, you only need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"start = true"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"@RootNavGraph(start = true)\n@NavGraph\nannotation class YourNavGraph(\n    val start: Boolean = false\n)\n")),(0,i.kt)("p",null,"This makes ",(0,i.kt)("inlineCode",{parentName:"p"},"your")," nav graph be nested in ",(0,i.kt)("inlineCode",{parentName:"p"},"root")," and be its starting route."),(0,i.kt)("div",{style:{textAlign:"center"}},"..."),(0,i.kt)("div",{style:{textAlign:"center",padding:15}}),(0,i.kt)("p",null,"With this mechanism of making navigation graphs and use their annotations to annotate either nested navigation graphs or the destinations that should belong to it, you can make an entire graph in any way you may want."),(0,i.kt)("p",null,"The most common use case, is to create nested navigation graphs inside root (like in the above ",(0,i.kt)("inlineCode",{parentName:"p"},"SettingsNavGraph")," example) and pass ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraphs.root")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationsNavHost"),". This way, all destinations and navgraphs belong to the root one, and they get registered in the ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationsNavHost")," call."),(0,i.kt)("h3",{id:"deprecated-through-destination-annotation"},"(DEPRECATED) Through @Destination annotation"),(0,i.kt)("p",null,"By default, Compose Destinations reads info from your ",(0,i.kt)("inlineCode",{parentName:"p"},"@Destination")," annotations to build the ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraphs")," object.\nIf you want some screens to be part of a nested navigation graph, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"navGraph")," argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"@Destination")," annotation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Destination(\n    navGraph = "settings",\n    start = true\n)\n@Composable\nfun SettingsScreen() { /*...*/ }\n')),(0,i.kt)("p",null,'All annotated Composables with the same "navGraph" argument will then belong to this navigation graph. You can access its properties with ',(0,i.kt)("inlineCode",{parentName:"p"},"NavGraphs.[yourNavGraphName]"),". You can navigate to the graph itself with ",(0,i.kt)("inlineCode",{parentName:"p"},"destinationsNavigator.navigate(NavGraphs.[yourNavGraphName])"),". "),(0,i.kt)("p",null,'Each navigation graph needs one and only one start destination. A compile check is in place to enforce this. You can define that with the "start" argument (as seen in the above example).'),(0,i.kt)("h2",{id:"manually-defining-navigation-graphs"},"Manually defining navigation graphs"),(0,i.kt)("p",null,"You can also manually define navigation graphs by instantiating ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraphSpec"),'s which, as shown above, is just a normal interface. If your app is multi module, you\'ll likely have to do it, so that you can gather all destinations / nav graphs from other modules into a single "top-level" navigation graph to pass to ',(0,i.kt)("inlineCode",{parentName:"p"},"DestinationsNavHost")," call.\nIf you do this, we recommend having a globally accessible object containing the nav graphs since they don't contain any state and you can easily pass them to the ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationNavHost")," calls, check if certain ",(0,i.kt)("inlineCode",{parentName:"p"},"Destination")," belongs to some graph, get the ",(0,i.kt)("inlineCode",{parentName:"p"},"Destination")," corresponding to a ",(0,i.kt)("inlineCode",{parentName:"p"},"NavBackStackEntry"),", etc. "),(0,i.kt)("p",null,"That said, you are free to organize them as you prefer. In a big app, it may be better to have multiple of these ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraph"),"s aggregator objects, for example. You can even instantiate this class just as you pass it to ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationsNavHost"),"."),(0,i.kt)("p",null,"Also, it won't make sense for the library to be generating the ",(0,i.kt)("inlineCode",{parentName:"p"},"NavGraphs")," object anymore. You should disable it adding this into your module's ",(0,i.kt)("inlineCode",{parentName:"p"},"build.gradle"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-gradle"},'ksp {\n    arg("compose-destinations.generateNavGraphs", "false")\n}\n')),(0,i.kt)("p",null,"If you disable this task, Compose Destinations will print some warnings if you are using ",(0,i.kt)("inlineCode",{parentName:"p"},"@NavGraph")," annotations in any ",(0,i.kt)("inlineCode",{parentName:"p"},"@Destination")," annotation (since these will be ignored)."),(0,i.kt)("h2",{id:"vanilla-navhosts"},'"Vanilla NavHosts"'),(0,i.kt)("p",null,"Finally, you can opt to not use ",(0,i.kt)("inlineCode",{parentName:"p"},"DestinationsNavHost"),". This approach is described in more details ",(0,i.kt)("a",{parentName:"p",href:"navhosts#vanilla-navhosts"},"here"),".\nBy doing that, you will be defining the Navigation graphs of the ",(0,i.kt)("inlineCode",{parentName:"p"},"NavHost")," while dealing with arguments, and calling the Composables."),(0,i.kt)("p",null,"In the end, the fact that we included this approach in both sections speaks to why we believe it's not the best approach: you are dealing with multiple concerns (defining the navigation graphs, getting the nav arguments, calling each composable) and the a way to check (both at runtime and by looking at the code) how the Navigation graphs of your app are defined, is less immediate compared to when you have an object that just contains the information about the graphs."))}u.isMDXComponent=!0}}]);