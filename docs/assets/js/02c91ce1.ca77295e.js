"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[6467],{135:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=t(4848),o=t(8453);const r={sidebar_position:10},s="Destination Wrappers",a={id:"destination-wrappers",title:"Destination Wrappers",description:"If you're looking to share logic or UI with multiple screen destinations, you may want to try using what we call Destination wrappers.",source:"@site/docs/destination-wrappers.md",sourceDirName:".",slug:"/destination-wrappers",permalink:"/v2/destination-wrappers",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/docs/destination-wrappers.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Deep links",permalink:"/v2/deeplinks"},next:{title:"Multi module setup",permalink:"/v2/multi-module-setup"}},l={},c=[{value:"Example 1: Wrapping screens with a PIN entry",id:"example-1-wrapping-screens-with-a-pin-entry",level:2},{value:"Example 2: Wrapping screens with a &quot;no network banner&quot;",id:"example-2-wrapping-screens-with-a-no-network-banner",level:2},{value:"About <code>DestinationWrapper</code>",id:"about-destinationwrapper",level:2}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"destination-wrappers",children:"Destination Wrappers"}),"\n",(0,i.jsxs)(n.p,{children:["If you're looking to share logic or UI with multiple screen destinations, you may want to try using what we call Destination wrappers.",(0,i.jsx)(n.br,{}),"\n","Let's see a couple examples. The examples might not be the best, but hopefully they're good enough to give you ideas of what you could do with wrappers."]}),"\n",(0,i.jsx)(n.h2,{id:"example-1-wrapping-screens-with-a-pin-entry",children:"Example 1: Wrapping screens with a PIN entry"}),"\n",(0,i.jsx)(n.p,{children:"Say you want to have some screens be protected by PIN.\nYou could do this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"object PinEntryWrapper : DestinationWrapper {\n\n    @Composable\n    override fun <T> DestinationScope<T>.Wrap(\n        screenContent: @Composable () -> Unit\n    ) {\n        val vm = viewModel<PinEntryWrapperViewModel>()\n        val correctPinEntered by vm.correctPinEntered.collectAsState()\n\n        if (!pinEnteredCorrectly) {\n            // SHOW YOUR PIN ENTRY UI HERE\n        } else {\n            screenContent()\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"And then apply the wrapper on all Destinations you want to protect this way:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Destination(\n    wrappers = [PinEntryWrapper::class] // \ud83d\udc48 \n)\n@Composable\nfun MyScreen() { /*...*/ }\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"hint",type:"info",children:(0,i.jsxs)(n.p,{children:["Keep in mind you can create your own Destination annotation, say, for the above example, ",(0,i.jsx)(n.code,{children:"PinProtectedDestination"}),", and use that instead of defining the wrapper manually on each destination. Read about how to do it ",(0,i.jsx)(n.a,{href:"defining-destinations#centralizing-destination-annotation-configuration",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"example-2-wrapping-screens-with-a-no-network-banner",children:'Example 2: Wrapping screens with a "no network banner"'}),"\n",(0,i.jsx)(n.p,{children:"On the previous example we decided to show either a PIN entry OR the screen. In this one, we'll always show the screen, but we'll also show a banner on top of it if there is no network."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"object NoNetworkBannerWrapper : DestinationWrapper {\n\n    @Composable\n    override fun <T> DestinationScope<T>.Wrap(\n        screenContent: @Composable () -> Unit\n    ) {\n        val vm = viewModel<NetworkBannerViewModel>()\n        val isNetworkAvailable by vm.isNetworkAvailable.collectAsState()\n\n        Column {\n            if (!isNetworkAvailable) {\n                NoNetworkBanner() // composable that shows a no network banner\n            }\n            \n            screenContent()\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"about-destinationwrapper",children:["About ",(0,i.jsx)(n.code,{children:"DestinationWrapper"})]}),"\n",(0,i.jsx)(n.p,{children:"Things to note about DestinationWrapper:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DestinationWrapper"})," is an interface you'll need to implement"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"Wrap"})," method has a ",(0,i.jsx)(n.code,{children:"DestinationScope"})," receiver. Same thing you get when calling your composables manually. You can use it to access:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"destination"})," that the wrapper is called to wrap"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"navArgs"})," type safe args of the destination being wrapped"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"buildDependencies()"})," which returns the dependencies provided to the destination via ",(0,i.jsx)(n.code,{children:"dependencyContainerBuilder"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"navBackStackEntry"})," correspondent to the destination being wrapped"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"navController"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"destinationsNavigator"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"Wrap"})," method receives a ",(0,i.jsx)(n.code,{children:"screenContent"})," lambda. You should call it when/where you want to call the destination composable."]}),"\n",(0,i.jsxs)(n.li,{children:["Your screens can use multiple wrappers. In that case the order they're set on matters. For example, if you set Wrapper1 and Wrapper2 like ",(0,i.jsx)(n.code,{children:"wrappers = [Wrapper1::class, Wrapper2::class]"}),", then ",(0,i.jsx)(n.code,{children:"Wrapper1"}),"'s ",(0,i.jsx)(n.code,{children:"screenContent"})," lambda will actually call ",(0,i.jsx)(n.code,{children:"Wrapper2"}),". ",(0,i.jsx)(n.code,{children:"Wrapper2"}),"'s ",(0,i.jsx)(n.code,{children:"screenContent"})," will be the destination composable."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);