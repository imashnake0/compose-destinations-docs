"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[4124],{5212:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=t(4848),o=t(8453);const i={sidebar_position:11},s="Multi module setup",l={id:"multi-module-setup",title:"Multi module setup",description:'If your application is split in multiple "vertical" / "feature" modules, then you\'ll want to let feature modules use their own navigation logic and exposing navigation graphs so that your "main" module can get all of these graphs and include them in a top level graph to call DestinationsNavHost with.',source:"@site/docs/multi-module-setup.md",sourceDirName:".",slug:"/multi-module-setup",permalink:"/v2/multi-module-setup",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/docs/multi-module-setup.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"Destination Wrappers",permalink:"/v2/destination-wrappers"},next:{title:"Testing",permalink:"/v2/testing"}},r={},d=[{value:"Feature module",id:"feature-module",level:2},{value:"Gradle setup",id:"gradle-setup",level:3},{value:"Exposing nav graphs",id:"exposing-nav-graphs",level:3},{value:"Exposing destinations",id:"exposing-destinations",level:3},{value:"Receive NavHost parameters",id:"receive-navhost-parameters",level:3},{value:"&quot;DestinationsNavHost module&quot;",id:"destinationsnavhost-module",level:2},{value:"Import nav graphs",id:"import-nav-graphs",level:3},{value:"Import destinations",id:"import-destinations",level:3},{value:"Call <code>DestinationsNavHost</code>",id:"call-destinationsnavhost",level:3},{value:"Send NavHost parameters",id:"send-navhost-parameters",level:4}];function h(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"multi-module-setup",children:"Multi module setup"}),"\n",(0,a.jsxs)(n.p,{children:['If your application is split in multiple "vertical" / "feature" modules, then you\'ll want to let feature modules use their own navigation logic and exposing navigation graphs so that your "main" module can get all of these graphs and include them in a top level graph to call ',(0,a.jsx)(n.code,{children:"DestinationsNavHost"})," with."]}),"\n",(0,a.jsx)(n.p,{children:'In the next sections, we\'ll see how to achieve this with Compose Destinations. We\'ll be talking about these two kinds of modules "feature module" and "DestinationsNavHost module", but you can take these same concepts for any sort of relationship between two modules where one module is being depended on by another.'}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Your feature module A depends on modules B and C."}),"\n",(0,a.jsx)(n.li,{children:'Modules B and C expose their own nav graphs. (in this case these would be the "feature modules" since they are depended on by Module A)'}),"\n",(0,a.jsx)(n.li,{children:'Module A prepares "ModuleAGraph" by including B and C graphs, and possibly adding more destinations / nested graphs of its own.'}),"\n",(0,a.jsx)(n.li,{children:'Main module includes the "ModuleAGraph" without ever depending or knowing about B and C.'}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"feature-module",children:"Feature module"}),"\n",(0,a.jsx)(n.h3,{id:"gradle-setup",children:"Gradle setup"}),"\n",(0,a.jsx)(n.p,{children:"Both of these are not mandatory, but they are recommended:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'ksp {\n    // used on some of the generated code, including default package name\n    arg("compose-destinations.moduleName", "profile")\n    // and if you want to generate mermaid graph files for this module\'s graphs: \n    // (ideally use the same path for all modules, so that navigation in the html works well)\n    arg("compose-destinations.htmlMermaidGraph", "$rootDir//navigation-docs")\n    arg("compose-destinations.mermaidGraph", "$rootDir/navigation-docs")\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"exposing-nav-graphs",children:"Exposing nav graphs"}),"\n",(0,a.jsx)(n.p,{children:"Usually a feature module wants to expose one or more navigation graphs. These will be included (nested) in some other graph of the module that depends on it."}),"\n",(0,a.jsx)(n.p,{children:"Here is how to do it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@NavGraph<ExternalModuleGraph>\ninternal annotation class ProfileGraph\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Notice"})," the ",(0,a.jsx)(n.code,{children:"ExternalModuleGraph"})," which is a special annotation to be used specifically on this case when this module doesn't actually know what will be the parent of ",(0,a.jsx)(n.code,{children:"ProfileGraph"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"And use it in any Composable destination or nav graph (if you want to have some graph nested on this one)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"/*public*/ data class ProfileNavGraphs(val id: String)\n\n@Destination<ProfileGraph>(\n    start = true,\n    navArgs = ProfileNavGraphs::class,\n    visibility = CodeGenVisibility.INTERNAL\n)\n@Composable\ninternal fun MainProfileScreen() { /*...*/ }\n\n@NavGraph<ProfileGraph>(visibility = CodeGenVisibility.INTERNAL)\ninternal annotation class ProfileSettingsGraph\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Notice"})," all the ",(0,a.jsx)(n.code,{children:"internal"}),"s used as well as ",(0,a.jsx)(n.code,{children:"CodeGenVisibility.INTERNAL"}),". You'll probably want to reduce what you're exposing to other modules by keeping only the generated ",(0,a.jsx)(n.code,{children:"ProfileNavGraph"})," (in this example) itself public. Nested graphs also don't need to be public."]}),"\n",(0,a.jsx)(n.p,{children:"If your nav graph or start destination (or both!) have navigation arguments, then these also need to be public since they're part of this module's API. Other modules need to use them to navigate to this module's graph."}),"\n",(0,a.jsx)(n.h3,{id:"exposing-destinations",children:"Exposing destinations"}),"\n",(0,a.jsx)(n.p,{children:"On some less common setups, you may want to expose destinations."}),"\n",(0,a.jsx)(n.p,{children:"To do that, do:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@Destination<ExternalModuleGraph>\n@Composable\nfun MyScren() { /*...*/ }\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Notice"})," the ",(0,a.jsx)(n.code,{children:"ExternalModuleGraph"})," which is a special annotation to be used specifically on this case when this module doesn't actually know what will be the parent of ",(0,a.jsx)(n.code,{children:"MyScren"})," destination."]}),"\n",(0,a.jsx)(n.h3,{id:"receive-navhost-parameters",children:"Receive NavHost parameters"}),"\n",(0,a.jsxs)(n.p,{children:["As pointed out ",(0,a.jsx)(n.a,{href:"arguments/nav-host-parameters",children:"here"}),", you'll often have to pass stuff from your ",(0,a.jsx)(n.code,{children:"DestinationsNavHost"})," call.\nThis may happen even more if your feature modules don't know about each other, since when you want to navigate to another feature, you won't have any direct way of doing so, so the tying party will be the \"",(0,a.jsx)(n.code,{children:"DestinationsNavHost"}),' module" since it knows about all others.']}),"\n",(0,a.jsxs)(n.p,{children:['To do this, your feature module should expose some "setup" functions, depending if it needs to manually call some of its Composables, or just pass dependencies or both. These two ways are also described ',(0,a.jsx)(n.a,{href:"arguments/nav-host-parameters",children:"here"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"package my.pckg.feature.profile\n\ninterface ExternalNavigator {\n    fun navigateToFeatureX(arg1: String)\n    \n    fun navigateToFeatureY()\n}\n\n@Composable\nfun DependenciesContainerBuilder<*>.ProfileDependencies(\n    externalNavigator: ExternalNavigator\n) {\n    dependency(externalNavigator)\n}\n\nfun ManualComposableCallsBuilder.profileManualCalls(\n    // something you want to pass to screens this way\n) {\n    composable(ProfileAccountSettingsDestination) {\n        // if you need to mix these two ways and get dependencies passed in via the above ProfileDependencies\n        val dependencies = buildDependencies()\n        ProfileAccountSettings(\n            externalNavigator = dependencies.require(),\n            onOnboardingFinished = onOnboardFinished\n        )\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Notes about above example:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:'Most likely, you don\'t need both "dependencies" and "manual calls". One of the two as explained in the nav host parameters page, should be enough. But, it\'s totally fine if you need both.'}),"\n",(0,a.jsxs)(n.li,{children:["I've used an interface for the navigator that can navigate to external destinations/graphs. You can also pass lambdas, although in that case you'd have to use manual calls and call all the composables that need those lambdas.",(0,a.jsx)(n.br,{}),"\n","With the ",(0,a.jsx)(n.code,{children:"ProfileDependencies"})," method, we are making this navigator available to all destinations of this module. They just need to request for it, and the library will provide it."]}),"\n",(0,a.jsxs)(n.li,{children:["You can remove ",(0,a.jsx)(n.code,{children:"@Composable"})," from ",(0,a.jsx)(n.code,{children:"ProfileDependencies"})," if you don't need it to access any composition locals or any compose API."]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"DestinationsNavHost"})," module should call these functions to provide all dependencies, as we'll see later in this page."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"destinationsnavhost-module",children:'"DestinationsNavHost module"'}),"\n",(0,a.jsx)(n.h3,{id:"import-nav-graphs",children:"Import nav graphs"}),"\n",(0,a.jsx)(n.p,{children:"To import nav graphs from other modules, nesting them to a graph of the current module, do:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@NavHostGraph\nannotation class MainGraph {\n\n    @ExternalNavGraph<FeatureXNavGraph>\n    @ExternalNavGraph<ProfileNavGraph>\n    @ExternalNavGraph<LoginNavGraph>(start = true)\n    companion object Includes\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This would include ",(0,a.jsx)(n.code,{children:"FeatureXNavGraph"})," and ",(0,a.jsx)(n.code,{children:"ProfileNavGraph"}),' as nested on this "main" graph. The example uses ',(0,a.jsx)(n.code,{children:"NavHostGraph"})," but you can do this in any nav graph, even if it's itself nested on another one."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ExternalNavGraph"})," is an annotation that contains some parameters you can use to configure or add/override some of the details of what you're including with it (like the ",(0,a.jsx)(n.code,{children:"start"})," we see on the example):"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"start"})," - defines this navigation graph as the start of the navigation graph it is being included on."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"deepLinks"})," - adds ",(0,a.jsx)(n.code,{children:"DeepLink"}),"s to this nav graph. Both these and the deep links defined on the declaring module (if any) can be used to navigate to this nav graph"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"defaultTransitions"})," - overrides animations set on the declaring module (if any)."]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["You can use this ",(0,a.jsx)(n.code,{children:"MainGraph"})," annotation to include other destinations / graphs that are defined in the same module as itself."]})}),"\n",(0,a.jsx)(n.h3,{id:"import-destinations",children:"Import destinations"}),"\n",(0,a.jsx)(n.p,{children:"To import destinations from another module, do:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@NavHostGraph\nannotation class MainGraph {\n    \n    @ExternalDestination<AnotherModuleDestination>\n    companion object Includes\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This will include ",(0,a.jsx)(n.code,{children:"AnotherModuleDestination"}),' in the "main" graph.']}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ExternalDestination"})," is an annotation that contains some parameters you can use to customize or add/override some aspects of what you're including with it:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"start"})," - defines this destination as the start of the navigation graph it is being included on."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"deepLinks"})," - adds ",(0,a.jsx)(n.code,{children:"DeepLink"}),"s to this destination. Both these and the deep links defined on the declaring module (if any) can be used to navigate to this destination."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"style"})," - overrides ",(0,a.jsx)(n.code,{children:"DestinationStyle"})," for this destination. The defined style on the declaring module will be ignored."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"wrappers"})," - adds ",(0,a.jsx)(n.code,{children:"DestinationWrapper"}),". Both these and the ones defined on the declaring module will be applied."]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"important",children:(0,a.jsxs)(n.p,{children:["Generated Destinations contain navigation stuff like the route. Routes should be unique. So you cannot import another module's Destination to more than one graph.",(0,a.jsx)(n.br,{}),"\n","So, if you find yourself wanting to do this, you should instead expose the actual Composable, untied from any navigation stuff, then preparing multiple ",(0,a.jsx)(n.code,{children:"@Destination"})," Composables that just call that one."]})}),"\n",(0,a.jsxs)(n.h3,{id:"call-destinationsnavhost",children:["Call ",(0,a.jsx)(n.code,{children:"DestinationsNavHost"})]}),"\n",(0,a.jsxs)(n.p,{children:["Following the example above, where we've setup a ",(0,a.jsx)(n.code,{children:"MainGraph"}),", this will generate a ",(0,a.jsx)(n.code,{children:"MainNavGraph"})," object containing nav graphs and destinations included by both the ",(0,a.jsx)(n.code,{children:"External"})," annotations and all the destinations and graphs of this same module using it."]}),"\n",(0,a.jsxs)(n.p,{children:["You should use it to pass to ",(0,a.jsx)(n.code,{children:"DestinationsNavHost"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"DestinationsNavHot(\n    navGraph = NavGraphs.main // or just MainNavGraph\n)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"send-navhost-parameters",children:"Send NavHost parameters"}),"\n",(0,a.jsx)(n.p,{children:'If any of your feature modules expect "nav host" parameters, you should also call their "setup" functions at this point. For example:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val navController = rememberNavController()\n\nDestinationsNavHost(\n    navGraph = NavGraphs.main,\n    navController = navController,\n    // for calling DependenciesContainerBuilder functions, following this page's examples\n    dependenciesContainerBuilder = {\n        navGraph(ProfileNavGraph) {\n            val externalNavigator = remember(navBackStackEntry) {\n                createExternalNavigator(navController)\n            }\n            ProfileDependencies(externalNavigator)\n        }\n    }\n) {\n    // for calling ManualComposableCallsBuilder functions, following this page's examples\n    profileManualCalls(/*whatever you need to pass here*/)\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var a=t(6540);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);