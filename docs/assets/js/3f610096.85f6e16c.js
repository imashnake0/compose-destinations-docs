"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[114],{7917:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var t=i(4848),s=i(8453);const a={sidebar_position:9},r="Deep links",o={id:"deeplinks",title:"Deep links",description:"Deep links to screen Composables and NavGraphs are supported with Compose Destinations.",source:"@site/docs/deeplinks.md",sourceDirName:".",slug:"/deeplinks",permalink:"/v2/deeplinks",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/docs/deeplinks.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Styles and Animations",permalink:"/v2/styles-and-animations"},next:{title:"Destination Wrappers",permalink:"/v2/destination-wrappers"}},l={},d=[{value:"FULL_ROUTE_PLACEHOLDER",id:"full_route_placeholder",level:2},{value:"Screens with mandatory complex navigation arguments types",id:"screens-with-mandatory-complex-navigation-arguments-types",level:2},{value:"Arrays / ArrayLists arguments on deep links",id:"arrays--arraylists-arguments-on-deep-links",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"deep-links",children:"Deep links"}),"\n",(0,t.jsx)(n.p,{children:"Deep links to screen Composables and NavGraphs are supported with Compose Destinations."}),"\n",(0,t.jsx)(n.p,{children:"You can define deep links to a destination like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'@Destination<RootGraph>(\n  deepLinks = [\n    DeepLink(\n      uriPattern = "https://myapp.com/user/{id}"\n    )\n  ]\n)\n@Composable\nfun UserScreen(\n  navigator: DestinationsNavigator,\n  id: Int\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Or to NavGraphs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'@NavGraph(\n    deepLinks = [\n      DeepLink(\n        uriPattern = "https://myapp.com/user/{id}"\n      )\n    ],\n    navArgs = UserGraph.Args::class\n)\nannotation class UserGraph {\n    data class Args(val id: Int)\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Besides ",(0,t.jsx)(n.code,{children:"uriPattern"}),", ",(0,t.jsx)(n.code,{children:"DeepLink"})," class has other ways of defining it like ",(0,t.jsx)(n.code,{children:"action"})," and ",(0,t.jsx)(n.code,{children:"mimetype"}),". You can read more in ",(0,t.jsx)(n.a,{href:"https://developer.android.com/jetpack/compose/navigation#deeplinks",children:"official documentation"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"full_route_placeholder",children:"FULL_ROUTE_PLACEHOLDER"}),"\n",(0,t.jsxs)(n.p,{children:["You can also use the placeholder suffix ",(0,t.jsx)(n.code,{children:"FULL_ROUTE_PLACEHOLDER"})," in your ",(0,t.jsx)(n.code,{children:"uriPattern"}),". In the code generation process, it will be replaced with the full route of the destination which contains all the destination arguments. So, for example, this would result in the same ",(0,t.jsx)(n.code,{children:"uriPattern"})," as the above example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'@Destination(\n  route = "user",\n  deepLinks = [\n    DeepLink(\n      uriPattern = "https://myapp.com/$FULL_ROUTE_PLACEHOLDER"\n    )\n  ]\n)\n@Composable\nfun UserScreen(\n  navigator: DestinationsNavigator,\n  id: Int\n)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The cool thing about using ",(0,t.jsx)(n.code,{children:"FULL_ROUTE_PLACEHOLDER"})," is that you can always use the corresponding generated ",(0,t.jsx)(n.code,{children:"Destination"})," invoke function as if you were navigating to it. Then, instead of passing the resulting ",(0,t.jsx)(n.code,{children:"Direction"})," to a navigator, you call ",(0,t.jsx)(n.code,{children:".route"})," on it and use that when building the deep link URI:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val validUserScreenRoute = UserScreenDestination(id = 1).route\nval uriForUserScreen = "https://myapp.com/$validUserScreenRoute".toUri()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The above URI will always match the ",(0,t.jsx)(n.code,{children:"UserScreen"})," correctly even if you add more arguments and even if some of them are complex types (",(0,t.jsx)(n.code,{children:"Parcelable"}),", ",(0,t.jsx)(n.code,{children:"Array"}),", etc). Also, if the added arguments are mandatory, you will have to come here and add them as well, otherwise it's a compile-time error! Neat!"]}),"\n",(0,t.jsx)(n.h2,{id:"screens-with-mandatory-complex-navigation-arguments-types",children:"Screens with mandatory complex navigation arguments types"}),"\n",(0,t.jsxs)(n.p,{children:["If you have a screen that declares a mandatory navigation argument of ",(0,t.jsx)(n.code,{children:"Parcelable"}),"/",(0,t.jsx)(n.code,{children:"Serializable"}),"/",(0,t.jsx)(n.a,{href:"https://github.com/Kotlin/kotlinx.serialization",children:"@kotlinx.serialization.Serializable"})," type (or Array of those), you need to be explicit about how that type is represented in the deep link route you are expecting.\nFor this, you need to use ",(0,t.jsx)(n.code,{children:"@NavTypeSerializer"})," annotation in a class that implements either ",(0,t.jsx)(n.code,{children:"DestinationsNavTypeSerializer<YOUR_NAV_ARG_TYPE>"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@Parcelize\ndata class Things(\n    val thingOne: String,\n    val thingTwo: String\n) : Parcelable\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'@NavTypeSerializer\nclass ThingsNavTypeSerializer : DestinationsNavTypeSerializer<Things> {\n\n    override fun toRouteString(value: Things): String {\n        return "${value.thing1};${value.thing2}"\n    }\n\n    override fun fromRouteString(routeStr: String): Things {\n        val things = routeStr.split(";")\n        return Things(things[0], things[1])\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"After this, you'd be able to use a deep link for this destination:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'@Destination(\n    deepLinks = [\n        DeepLink(uriPattern = "https://myapp.com/things_screen/{things}")\n    ]\n)\n@Composable\nfun ThingsScreen(\n    things: Things\n) {\n    //...\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["And the link that would lead users to this screen would be ",(0,t.jsx)(n.code,{children:"https://myapp.com/things_screen/thingOne;thingTwo"}),". Given the above ",(0,t.jsx)(n.code,{children:"@NavTypeSerializer"})," annotated class, the navigation argument received would be created by calling the ",(0,t.jsx)(n.code,{children:"fromRouteString"})," method (so in the end, it would be ",(0,t.jsx)(n.code,{children:'Things("thingOne", "thingTwo")'}),")."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["For ",(0,t.jsx)(n.a,{href:"arguments/navigation-arguments#custom-navigation-argument-types",children:"custom navigation types"}),", since they are so only because you defined a ",(0,t.jsx)(n.code,{children:"@NavTypeSerializer"}),", the string representation in the deep link will need to match what is expected there in the ",(0,t.jsx)(n.code,{children:"fromRouteString"})," method."]})}),"\n",(0,t.jsx)(n.h2,{id:"arrays--arraylists-arguments-on-deep-links",children:"Arrays / ArrayLists arguments on deep links"}),"\n",(0,t.jsxs)(n.p,{children:["Array and ArrayList navigation arguments are represented on deep links as comma separated values surrounded with brackets (example: ",(0,t.jsx)(n.code,{children:"[1,2,3]"}),'). If each of those values needs to be "URI encoded" to be safely used on URI, then your commas need to be encoded twice. This is the only way we can safely parse the value from the route without considering other possible commas that could otherwise be present on one of the values.']}),"\n",(0,t.jsx)(n.p,{children:"So:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"If your app is the one prepraring the URI for the deep link"})," (example: to pass to a notification) you can use the invoke method on the corresponding generated ",(0,t.jsx)(n.code,{children:"Destination"})," (as if you were navigating to it) and then call ",(0,t.jsx)(n.code,{children:".route"})," on the result of that. This will give you a valid route you can append to the deep link prefix of your app which will always work and you don't need to worry about how the arguments are represented."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"If the deep link is prepared from outside the app"}),', remember that the commas need to be "doubly encoded", i.e, you need to separate values with "%252C", for the following types:']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Array<String>"}),", ",(0,t.jsx)(n.code,{children:"ArrayList<String>"}),", ",(0,t.jsx)(n.code,{children:"Array"})," and ",(0,t.jsx)(n.code,{children:"ArrayList"})," of ",(0,t.jsx)(n.code,{children:"Parcelable"}),", ",(0,t.jsx)(n.code,{children:"Serializable"}),", ",(0,t.jsx)(n.code,{children:"@Serializable"})," and  ",(0,t.jsx)(n.a,{href:"arguments/navigation-arguments#custom-navigation-argument-types",children:"custom nav types"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Taking the same example as above but changing the argument to array:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'@Destination(\n    deepLinks = [\n        DeepLink(uriPattern = "https://myapp.com/things_screen/{things}")\n    ]\n)\n@Composable\nfun ThingsScreen(\n    things: Array<Things>\n) {\n    //...\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, a deep link for this screen (also considering the above ",(0,t.jsx)(n.code,{children:"@NavTypeSerializer"}),") would be something like:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"https://myapp.com/things_screen/[thingOne;thingTwo%252CthingThree;thingFour]"})}),"\n",(0,t.jsxs)(n.p,{children:["And this would result in the app navigating to the above ",(0,t.jsx)(n.code,{children:"ThingsScreen"})," with a navigation argument equal to the result of ",(0,t.jsx)(n.code,{children:'arrayOf(Things("thingOne", "thingTwo"), Things("thingThree", "thingFour"))'}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);