"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[1047],{364:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var i=t(4848),o=t(8453);const s={sidebar_position:8},a="Styles and Animations",l={id:"styles-and-animations",title:"Styles and Animations",description:"Compose Destinations allows you to define different styles for your Composable screens.",source:"@site/docs/styles-and-animations.md",sourceDirName:".",slug:"/styles-and-animations",permalink:"/v2/styles-and-animations",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/docs/styles-and-animations.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Defining Navigation Graphs",permalink:"/v2/defining-navgraphs"},next:{title:"Deep links",permalink:"/v2/deeplinks"}},r={},d=[{value:"Default Style",id:"default-style",level:2},{value:"Animated Style",id:"animated-style",level:2},{value:"Dialog Style",id:"dialog-style",level:2},{value:"BottomSheet Style",id:"bottomsheet-style",level:2},{value:"Override the annotation style at runtime",id:"override-the-annotation-style-at-runtime",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"styles-and-animations",children:"Styles and Animations"}),"\n",(0,i.jsxs)(n.p,{children:["Compose Destinations allows you to define different styles for your Composable screens.",(0,i.jsx)(n.br,{}),"\n",'These "styles" describe the way the Composable enters and leaves the screen or how it is shown.']}),"\n",(0,i.jsx)(n.p,{children:"Each destination can have one of these styles:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#default-style",children:"Default"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#animated-style",children:"Animated"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#dialog-style",children:"Dialog"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#bottomsheet-style",children:"BottomSheet"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The way you can choose this is by passing the ",(0,i.jsx)(n.code,{children:"style"})," argument to the ",(0,i.jsx)(n.code,{children:"@Destination"})," annotation, example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Destination(style = DestinationStyle.Dialog::class)\n@Composable\nfun SomeScreen() { /*...*/ }\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"hint",type:"info",children:(0,i.jsxs)(n.p,{children:["If you have an animation that you need to apply at runtime, for example, if the animation depends on some state that is only known in the DestinationsNavHost level, you can override whatever style is set in the annotation.\nRead more in the ",(0,i.jsx)(n.a,{href:"#override-the-annotation-style-at-runtime",children:(0,i.jsx)(n.em,{children:"Override the annotation style at runtime"})})," section."]})}),"\n",(0,i.jsx)(n.h2,{id:"default-style",children:"Default Style"}),"\n",(0,i.jsxs)(n.p,{children:["As you probably have guessed, this is the style that's going to be applied to all Destinations that don't explicitly use another style.\nInternally, it is similar to ",(0,i.jsx)(n.code,{children:"DestinationsStyle.Animated"}),", except it takes animations from the destination's parent nav graph."]}),"\n",(0,i.jsx)(n.h2,{id:"animated-style",children:"Animated Style"}),"\n",(0,i.jsxs)(n.p,{children:["The animated style enables you to define custom animations for your screen transitions. You can subclass ",(0,i.jsx)(n.code,{children:"DestinationStyle.Animated"})," class with an object class and define the enter and exit transitions with normal animation APIs."]}),"\n",(0,i.jsxs)(n.p,{children:["Since compose 1.7, you'll also be able to override a ",(0,i.jsx)(n.code,{children:"sizeTransform"})," as part of this class."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",metastring:"title=ProfileTransitions.kt",children:"object ProfileTransitions : DestinationStyle.Animated() {\n\n    override val enterTransition: AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition? = {\n    //...\n"})}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"(expand to see the full ProfileTransitions.kt)"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"object ProfileTransitions : DestinationStyle.Animated() {\n\n    override val enterTransition: AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition? = {\n        when (initialState.destination()) {\n            GreetingScreenDestination ->\n                slideInHorizontally(\n                    initialOffsetX = { 1000 },\n                    animationSpec = tween(700)\n                )\n            else -> null\n        }\n    }\n\n    override val exitTransition: AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition? = {\n        when (targetState.destination()) {\n            GreetingScreenDestination ->\n                slideOutHorizontally(\n                    targetOffsetX = { -1000 },\n                    animationSpec = tween(700)\n                )\n            else -> null\n        }\n    }\n    \n    override val popEnterTransition: AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition? = {\n        when (initialState.destination()) {\n            GreetingScreenDestination ->\n                slideInHorizontally(\n                    initialOffsetX = { -1000 },\n                    animationSpec = tween(700)\n                )\n            else -> null\n        }\n    }\n    \n    override val popExitTransition: AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition? = {\n        when (targetState.destination()) {\n            GreetingScreenDestination ->\n                slideOutHorizontally(\n                    targetOffsetX = { 1000 },\n                    animationSpec = tween(700)\n                )\n            else -> null\n        }\n    }\n}\n"})})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Destination(style = ProfileTransitions::class)\n@Composable\nfun AnimatedVisibilityScope.ProfileScreen() { /*...*/ }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice the ",(0,i.jsx)(n.code,{children:"AnimatedVisibilityScope"}),' receiver. This scope is available to all "non dialog" and "non bottom sheet" Composables in the nav graph.']}),"\n",(0,i.jsx)(n.h2,{id:"dialog-style",children:"Dialog Style"}),"\n",(0,i.jsxs)(n.p,{children:["This style will make your Composable be displayed as a dialog above the previous screen. ",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.code,{children:"DestinationStyle.Dialog"})," is also a class you can extend to specify a ",(0,i.jsx)(n.code,{children:"DialogProperties"})," field. This enables you to create specific configurations of Dialogs subclassing it with an ",(0,i.jsx)(n.code,{children:"object"}),". Then you can pass that object's class to the style argument, for example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"object NonDismissableDialog : DestinationStyle.Dialog() {\n    override val properties = DialogProperties(\n        dismissOnClickOutside = false,\n        dismissOnBackPress = false,\n    )\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Destination(style = NonDismissableDialog::class)\n@Composable\nfun SomeDialogScreen() { /*...*/ }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you declare the style as ",(0,i.jsx)(n.code,{children:"style = DestinationStyle.Dialog::class"}),", then the default ",(0,i.jsx)(n.code,{children:"DialogProperties"})," will be used."]}),"\n",(0,i.jsx)(n.h2,{id:"bottomsheet-style",children:"BottomSheet Style"}),"\n",(0,i.jsxs)(n.p,{children:["This style requires you to add ",(0,i.jsx)(n.code,{children:"io.github.raamcosta.compose-destinations:bottom-sheet"})," dependency.\nThe ",(0,i.jsx)(n.code,{children:"DestinationStyleBottomSheet"})," is a simple object that you can use to set this style."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Destination(style = DestinationStyleBottomSheet::class)\n@Composable\nfun ColumnScope.SomeBottomSheetScreen() { /*...*/ }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice the ",(0,i.jsx)(n.code,{children:"ColumnScope"})," receiver. This is optional if you're using the bottom sheet style and the reason is that the bottom sheet is internally placed inside a Column, so you can potentially do things that are only possible within that type of scope without needing another Column."]}),"\n",(0,i.jsxs)(n.p,{children:["Just as if you were working with Navigation-Material directly, you will need to wrap your top-most Composable with a ",(0,i.jsx)(n.code,{children:"ModalBottomSheetLayout"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val navController = rememberNavController()\n\nval bottomSheetNavigator = rememberBottomSheetNavigator()\nnavController.navigatorProvider += bottomSheetNavigator\n\nModalBottomSheetLayout(\n    bottomSheetNavigator = bottomSheetNavigator,\n    // other configuration for you bottom sheet screens, like:\n    sheetShape = RoundedCornerShape(16.dp),\n) {\n    // ...\n    DestinationsNavHost(\n        navController = navController\n        // ...\n    )\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"override-the-annotation-style-at-runtime",children:"Override the annotation style at runtime"}),"\n",(0,i.jsxs)(n.p,{children:["You might have some situations where animations at compile time, set on a different place is not ideal. For example, if your animation depends on some state that is available at the ",(0,i.jsx)(n.code,{children:"DestinationsNavHost"})," call."]}),"\n",(0,i.jsx)(n.p,{children:"In that case, you can override whatever is set (or not set, if you didn't specify, which makes sense if you're going to override it anyway), like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"DestinationsNavHost(\n    //...\n) {\n    // same place you can manually call composables\n    MyDestination animateWith SomeAnimatedStyleObject\n    \n    // OR more likely what you're looking for:\n    MyDestination.animateWith(\n        enterTransition = { /*...*/ },\n        exitTransition = { /*...*/ },\n        popEnterTransition = { /*...*/ },\n        popExitTransition = { /*...*/ },\n        sizeTransform = { /*...*/ },\n    )\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);